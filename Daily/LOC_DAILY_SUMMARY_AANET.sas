%INCLUDE "\\CSSSASAPP\CADA\SAS SOURCE CODE\PRODUCTION\SERVICE ACCOUNTS\SVC_SASUSER.SAS";
%INCLUDE "E:\SHARED\CADA\SAS SOURCE CODE\DEVELOPMENT\JHUBBARD\SKYNET REDESIGN\DATAMART REDESIGN\DAILY\DAILY_ERROR_INPUTS.SAS";

%LET LOC_LIB = AA_LOC;

/*DATASOURCE='NW-DQU-DB-01.AEAONLINE.NET\QA_03'*/

LIBNAME &LOC_LIB OLEDB DATASOURCE='RPTDB02.AEAONLINE.NET\AANET' PROVIDER=SQLOLEDB DBMAX_TEXT=32767 
               USER='SVC_SASUSER' PASSWORD='{SAS002}8E8C78044906924E47EBAD620CFCE3294AE9C1533DF26A16'
               PROPERTIES=("INITIAL CATALOG"=LGV4) SCHEMA=DBO;

LIBNAME AA_BTAG OLEDB DATASOURCE='RPTDB02.AEAONLINE.NET\AANET' PROVIDER=SQLOLEDB DBMAX_TEXT=32767 
               USER="&USER" PASSWORD=&PASSWORD
               PROPERTIES=("INITIAL CATALOG"=BTAGCOMMON) SCHEMA=DBO;

LIBNAME AA_PD OLEDB DATASOURCE='RPTDB02.AEAONLINE.NET\AANET' PROVIDER=SQLOLEDB DBMAX_TEXT=32767 
               USER="&USER" PASSWORD=&PASSWORD
               PROPERTIES=("INITIAL CATALOG"=PRIMEDECK) SCHEMA=DBO;

LIBNAME LOC_SRC "E:\SHARED\CADA\SAS DATA\DATAMART\LoC DAILY SUMMARY\";

LIBNAME SKYNET "E:\SHARED\CADA\SAS DATA\DATAMART\STDM\";

LIBNAME EDW ORACLE
	USER=&USER
	PW=&PASSWORD
	PATH=EDWPRD
	SCHEMA=EDW DEFER=YES;

LIBNAME BIORDEV ORACLE	
	USER=&USER
	PW=&PASSWORD
	PATH=BIOR
	SCHEMA=BIORDEV DEFER=YES;

LIBNAME BIOR ORACLE 
	USER=&USER
	PW=&PASSWORD
	PATH=BIOR
	SCHEMA=BIOR DEFER=YES;

LIBNAME ODSFIN ORACLE
	USER=&USER
	PW=&PASSWORD
	PATH=PEDWPROD1
	SCHEMA=SC_ODS_FIN DEFER=YES;


DATA _NULL_;
	CALL SYMPUTX('DAILY_LOGPATH',"E:\SHARED\CADA\LOGS\SKYNET V2",'G');
	CALL SYMPUTX('DAILY_FILE_PATH',"E:\SHARED\CADA\SAS SOURCE CODE\PRODUCTION\SKYNET V2\SKYNET REDESIGN\DATAMART REDESIGN\DAILY",'G');
%RUNQUIT(&job,&sub16);

/* NEW ORIGINATION AMOUNTS AND COUNTS BY DEAL */

PROC SQL;
	CREATE TABLE INITIAL_PULL AS
		SELECT 
		DISTINCT
          T1.TRNID, 
          T1.FC_UNIQUE_TRAN_NO, 
          T1.FC_TRAN_ID_OTHER, 
          T1.FC_PRODUCT_CD, 
          T1.FD_TRANSACTION_DTTM, 
          T1.FC_BUSINESS_UNIT_CD, 
          T1.FI_CENTER_ID, 
          T1.FC_LOANID, 
          T1.FN_LOAN_TOTAL_OWED, 
          T1.FC_CUSTOMER_ID, 
          T1.FC_CUST_INSTRUMENT_ABANBR, 
          T1.FC_CUST_INSTRUMENT_ACCT, 
          T1.FC_CUST_INSTRUMENT_NBR, 
          T1.FC_BANK_INSTRUMENT_ABANBR, 
          T1.FC_BANK_INSTRUMENT_ACCT, 
          T1.FC_BANK_INSTRUMENT_NBR, 
          T1.FC_TRANSACTION_CD, 
          T1.FC_FINANCIAL_DETAIL_CD, 
          T1.FC_FINANCIAL_DETAIL_AMT, 
          T1.FC_FINANCIAL_CD, 
          T1.FC_REVERSAL_CD, 
          T1.FC_LOAN_STATUS_CD_CURRENT, 
          T1.FC_LOAN_STATUS_ID_CURRENT, 
          T1.FC_LOAN_STATUS_CD_PREVIOUS, 
          T1.FC_LOAN_STATUS_ID_PREVIOUS, 
          T1.FC_LOAN_STATUSGROUP_CD_CURRENT, 
          T1.FC_LOAN_STATUSGROUP_ID_CURRENT, 
          T1.FC_LOAN_STATUSGROUP_CD_PREV, 
          T1.FC_LOAN_STATUSGROUP_ID_PREV, 
          T1.FC_PORTFOLIO_STATUS_CD_CURRENT, 
          T1.FC_PORTFOLIO_STATUS_ID_CURRENT, 
          T1.FC_PORTFOLIO_STATUS_CD_PREVIOUS, 
          T1.FC_PORTFOLIO_STATUS_ID_PREVIOUS, 
          T1.STATEMENT_DATE, 
          T1.DUE_DATE, 
          T1.DATEMODIFIED
	FROM AA_LOC.LOAN T2
	INNER JOIN 
	AA_LOC.FINANCIALACCTTRN T1
	ON(T2.LOANID=T1.FC_LOANID)
	WHERE T2.LOANTYPEID = 3
;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE PAST_DUE_PRE AS
		SELECT DISTINCT INPUT(FI_CENTER_ID,BEST10.) AS LOCNBR
			  ,FC_LOANID
			  ,PD.CYCLENUMBER
			  ,PD.CYCLEAMOUNTDUE
			  ,FC_LOAN_STATUS_CD_CURRENT
			  ,INPUT(PD.DUEDATE,YYMMDD10.) AS DUEDATE FORMAT=MMDDYY10.
		FROM INITIAL_PULL
		LEFT JOIN AA_LOC.LOANCYCLE PD
	ON(FC_LOANID=PD.LOANID)
	WHERE CYCLEAMOUNTDUE ^= 0 AND CALCULATED DUEDATE <= TODAY()-1
		  AND FC_LOAN_STATUS_CD_CURRENT = 'Past Due'
	ORDER BY LOCNBR
	        ,FC_LOANID
	    	,CYCLENUMBER
;
%RUNQUIT(&job,&sub16);

DATA _NULL_;
	CALL SYMPUTX('DATE',PUT(TODAY()-1,DATE9.),'G');
%RUNQUIT(&job,&sub16);

PROC TIMESERIES DATA=PAST_DUE_PRE OUT=DUE_DATE_BLOWOUT;
BY LOCNBR FC_LOANID;
ID DUEDATE INTERVAL=DAY END="&DATE"D;
VAR CYCLEAMOUNTDUE / ACCUMULATE=NONE SETMISSING=PREVIOUS;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE DUE_DATE_CALC AS
		SELECT TS.LOCNBR 
			  ,TS.FC_LOANID
	 		  ,TS.DUEDATE AS BUSINESSDT FORMAT=MMDDYY10.
			  ,DD.DUEDATE
			  ,TS.CYCLEAMOUNTDUE
			  ,INTCK('DAY',DD.DUEDATE,TS.DUEDATE) AS DPD
			  ,CASE WHEN CALCULATED DPD BETWEEN 1 AND 9 THEN 1 ELSE 0 END AS PASTDUECNT_1
			  ,CASE WHEN CALCULATED DPD BETWEEN 1 AND 9 THEN TS.CYCLEAMOUNTDUE ELSE 0 END AS PASTDUEAMT_1
			  ,CASE WHEN CALCULATED DPD >= 10 THEN 1 ELSE 0 END AS PASTDUECNT_2
			  ,CASE WHEN CALCULATED DPD >= 10 THEN TS.CYCLEAMOUNTDUE ELSE 0 END AS PASTDUEAMT_2
		FROM DUE_DATE_BLOWOUT TS
		LEFT JOIN
		PAST_DUE_PRE DD
		ON(TS.FC_LOANID=DD.FC_LOANID)
	ORDER BY TS.FC_LOANID
		    ,TS.DUEDATE
;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE PAST_DUE AS
		SELECT LOCNBR
			  ,BUSINESSDT
			  ,SUM(PASTDUECNT_1) AS PASTDUECNT_1
			  ,SUM(PASTDUEAMT_1) AS PASTDUEAMT_1
			  ,SUM(PASTDUECNT_2) AS PASTDUECNT_2
			  ,SUM(PASTDUEAMT_2) AS PASTDUEAMT_2
		FROM DUE_DATE_CALC
	GROUP BY LOCNBR
		    ,BUSINESSDT
;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE OPEN_LINES AS
		SELECT INPUT(FI_CENTER_ID,BEST10.) AS LOCNBR
		      ,INPUT(FC_BUSINESS_UNIT_CD,BEST10.) AS BUSINESS_UNIT
			  ,FC_LOANID AS DEALNBR
			  ,FD_TRANSACTION_DTTM AS BUSINESSDT FORMAT=DATETIME20.
/*			  ,COUNT(FC_LOANID) AS NEW_ORIGINATION_LINE_COUNT*/
			  ,SUM(FC_FINANCIAL_DETAIL_AMT) AS NEW_ORIGINATION_LINE_AMT
		FROM INITIAL_PULL
	 WHERE UPPER(FC_TRANSACTION_CD) = 'LINE OPEN'
/*	 	   AND FC_LOANID IN(SELECT LOANID FROM AA_LOC.LOAN WHERE LOANTYPEID = 3 AND)*/
	 GROUP BY CALCULATED LOCNBR
	 	     ,CALCULATED BUSINESS_UNIT
			 ,FC_LOANID
			 ,FD_TRANSACTION_DTTM
;
%RUNQUIT(&job,&sub16);

/* SUM TOGETHER BY LOCATION NUMBER AND BUSINESS DATE */
PROC SQL;
	CREATE TABLE BY_LOC AS	
		SELECT LOCNBR
			  ,BUSINESS_UNIT
			  ,DATEPART(BUSINESSDT) AS BUSINESSDT FORMAT=MMDDYY10.
			  ,COUNT(DEALNBR) AS NEW_ORIGINATION_LINE_COUNT
			  ,SUM(NEW_ORIGINATION_LINE_AMT) AS NEW_ORIGINATION_LINE_AMT
		FROM OPEN_LINES
	GROUP BY LOCNBR
		    ,BUSINESS_UNIT
			,BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* PULL BALANCE AT TIME OF EVENTS FOR ALL LINES THAT OPENED */
PROC SQL;
	CREATE TABLE TOTALOWED_1 AS
		SELECT DISTINCT FC_LOANID AS DEALNBR
			  ,INPUT(FI_CENTER_ID,BEST32.) AS LOCNBR
			  ,DATEPART(FD_TRANSACTION_DTTM) AS TRANDT FORMAT=MMDDYY10.
			  ,FN_LOAN_TOTAL_OWED AS TOTALOWED
			  ,NEW_ORIGINATION_LINE_AMT
			  ,CASE WHEN COMPRESS(UPPER(FC_PORTFOLIO_STATUS_CD_CURRENT)) = 'COMPLIANT' THEN 1
	  				WHEN COMPRESS(UPPER(FC_PORTFOLIO_STATUS_CD_CURRENT)) = 'DEFAULT' THEN 2
					WHEN COMPRESS(UPPER(FC_PORTFOLIO_STATUS_CD_CURRENT)) = 'CHARGEDOFF' THEN 3
					ELSE 0
			   END AS LOAN_STATUS
			  ,SUM(NEW_ORIGINATION_LINE_AMT,-FN_LOAN_TOTAL_OWED) AS TOTAL_AVAILABLE_CREDIT_1
	FROM OPEN_LINES OL
	INNER JOIN 
	&LOC_LIB..FINANCIALACCTTRN TRN
	ON(OL.DEALNBR=TRN.FC_LOANID)
/*	WHERE FC_LOANID IN(2855789, 2855796)*/
;
%RUNQUIT(&job,&sub16);


/* ################################# */
/*           Added 9.18.18           */
/* TO FIX THE TOTAL AVAILABLE CREDIT */
/* ################################# */

data totalowed_2;
	set totalowed_1;
	total_owed_2 = totalowed;
%RUNQUIT(&job,&sub16);

data totalowed;
	set totalowed_2;
	if total_owed_2 > NEW_ORIGINATION_LINE_AMT
		then total_owed_2 = NEW_ORIGINATION_LINE_AMT;
	else if total_owed_2 < 0
		then total_owed_2 = 0;

	TOTAL_AVAILABLE_CREDIT = SUM(NEW_ORIGINATION_LINE_AMT,-total_owed_2);
%RUNQUIT(&job,&sub16);

/* ####################### */
/*      End Additions      */
/* ####################### */

/* DEFAULT COUNTS AND AMOUNTS */
PROC SQL;
   CREATE TABLE WORK.DEFAULT_CNT_AMT AS 
   SELECT  INPUT(FI_CENTER_ID,BEST10.) AS LOCNBR
          ,DATEPART(FD_TRANSACTION_DTTM) FORMAT=MMDDYY10. AS BUSINESSDT
          ,FC_TRANSACTION_CD AS TRANCD
          ,FC_FINANCIAL_CD AS FINANCIALCD
          ,SUM(FC_FINANCIAL_DETAIL_AMT) AS DEFAULT_AMT
		  ,COUNT(DISTINCT FC_LOANID) AS DEFAULT_CNT
      FROM AA_LOC.FINANCIALACCTTRN
      WHERE COMPRESS(UPPER(FC_TRANSACTION_CD)) = 'DEFAULT'
      GROUP BY FI_CENTER_ID
              ,CALCULATED BUSINESSDT
              ,FC_TRANSACTION_CD
              ,FC_FINANCIAL_CD
      ORDER BY CALCULATED LOCNBR
			  ,CALCULATED BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* WRITE OFF COUNTS AND AMOUNTS */
PROC SQL;
	CREATE TABLE WORK.WO_CNT_AMT AS
		SELECT INPUT(FI_CENTER_ID,BEST10.) AS LOCNBR
			  ,DATEPART(FD_TRANSACTION_DTTM) FORMAT=MMDDYY10. AS BUSINESSDT
			  ,FC_TRANSACTION_CD AS TRANCD
			  ,FC_FINANCIAL_CD AS FINANCIALCD
			  ,SUM(FC_FINANCIAL_DETAIL_AMT) AS WO_AMT
			  ,COUNT(DISTINCT(FC_LOANID)) AS WO_CNT
		FROM AA_LOC.FINANCIALACCTTRN
	WHERE COMPRESS(UPPER(FC_TRANSACTION_CD)) = 'CHARGEDOFF'
	GROUP BY CALCULATED LOCNBR 
			,CALCULATED BUSINESSDT
            ,FC_TRANSACTION_CD
            ,FC_FINANCIAL_CD
    ORDER BY CALCULATED LOCNBR
			,CALCULATED BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* PULL ALL DRAW TRANSACTIONS */
PROC SQL;
	CREATE TABLE DRAWS AS
		SELECT INPUT(FI_CENTER_ID,BEST10.) AS LOCNBR
			  ,FC_LOANID AS DEALNBR
			  ,DATEPART(FD_TRANSACTION_DTTM) FORMAT=MMDDYY10. AS BUSINESSDT
			  ,FC_TRANSACTION_CD AS TRANCD
			  ,FC_FINANCIAL_CD AS FINANCIALCD
			  ,SUM(FC_FINANCIAL_DETAIL_AMT) AS DRAWAMT
			  ,COUNT(DISTINCT(FC_LOANID)) AS DRAWCNT
		FROM INITIAL_PULL
	WHERE COMPRESS(UPPER(FC_TRANSACTION_CD)) = 'DRAW' AND COMPRESS(UPPER(FC_FINANCIAL_CD)) = 'TENDER'
	GROUP BY CALCULATED LOCNBR
		    ,FC_LOANID
			,CALCULATED BUSINESSDT
            ,FC_TRANSACTION_CD
            ,FC_FINANCIAL_CD
    ORDER BY CALCULATED LOCNBR
		    ,FC_LOANID
			,CALCULATED BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* ONLY GRAB FIRST DRAW PER LINE */
DATA FIRST_DRAW_PRE;
	SET DRAWS;
	BY DEALNBR;
	IF FIRST.DEALNBR;
%RUNQUIT(&job,&sub16);

/* FIRST DRAW COUNT AND AMOUNT */
PROC SQL;
	CREATE TABLE FIRST_DRAW AS
		SELECT LOCNBR
			  ,BUSINESSDT
			  ,SUM(DRAWAMT) AS FIRSTDRAWAMT
			  ,SUM(DRAWCNT) AS FIRSTDRAWCNT
		FROM FIRST_DRAW_PRE
	GROUP BY LOCNBR
		    ,BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* OVERALL DRAW COUNT AND AMOUNT */
PROC SQL;
	CREATE TABLE OVERALL_DRAW AS
		SELECT LOCNBR
			  ,BUSINESSDT
			  ,SUM(DRAWAMT) AS OVERALLDRAWAMT
			  ,SUM(DRAWCNT) AS OVERALLDRAWCNT
		FROM WORK.DRAWS
		GROUP BY LOCNBR
			    ,BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/* LAST BALANCE PER DAY FOR TIMESERIES BLOWOUT */
DATA LAST_BAL;
	SET TOTALOWED;
	BY DEALNBR TRANDT;
	IF LAST.TRANDT;
%RUNQUIT(&job,&sub16);

PROC SORT DATA=LAST_BAL;
BY LOCNBR DEALNBR;
%RUNQUIT(&job,&sub16);

DATA _NULL_;
	CALL SYMPUTX('DATE',PUT(TODAY()-1,DATE9.),'G');
RUN;

/* BLOWOUT TOTAL AVAILABLE CREDIT */
PROC TIMESERIES DATA=LAST_BAL OUT=BLOW_OUT;
	BY LOCNBR DEALNBR;
	ID TRANDT INTERVAL=DAY END="&DATE"D;
	VAR TOTAL_AVAILABLE_CREDIT / ACCUMULATE=NONE SETMISSING=PREVIOUS;
%RUNQUIT(&job,&sub16);

/* BLOWOUT ACTIVE/DEFAULT COUNT AND AMOUNT */
PROC TIMESERIES DATA=LAST_BAL OUT=ACTIVE_CREDIT_TS;
	BY LOCNBR DEALNBR;
	ID TRANDT INTERVAL=DAY END="&DATE"D;
	VAR TOTALOWED / ACCUMULATE=NONE SETMISSING=PREVIOUS;
	VAR LOAN_STATUS / ACCUMULATE=NONE SETMISSING=PREVIOUS;
%RUNQUIT(&job,&sub16);

/* ACTIVE/DEFAULT COUNT AND AMOUNT */
PROC SQL;
	CREATE TABLE SUMMARIZE_ACTIVE AS
		SELECT LOCNBR
			  ,TRANDT AS BUSINESSDT FORMAT=MMDDYY10.
			  ,COUNT(CASE WHEN TOTALOWED ^= 0 AND LOAN_STATUS = 1 THEN DEALNBR END) AS ACTIVE_CNT
			  ,SUM(CASE WHEN TOTALOWED ^= 0 AND LOAN_STATUS = 1 THEN TOTALOWED ELSE 0 END) AS ACTIVE_AMT
			  ,COUNT(CASE WHEN TOTALOWED ^= 0 AND LOAN_STATUS = 2 THEN DEALNBR END) AS DEFAULT_CNT
			  ,SUM(CASE WHEN TOTALOWED ^= 0 AND LOAN_STATUS = 2 THEN TOTALOWED ELSE 0 END) AS DEFAULT_AMT
		FROM WORK.ACTIVE_CREDIT_TS
	GROUP BY LOCNBR
		    ,TRANDT
;
%RUNQUIT(&job,&sub16);

/* TOTAL AVAILABLE CREDIT */
PROC SQL;
	CREATE TABLE SUMMARIZE AS
		SELECT LOCNBR
		      ,TRANDT AS BUSINESSDT FORMAT=MMDDYY10.
			  ,SUM(TOTAL_AVAILABLE_CREDIT) AS TOTAL_AVAILABLE_CREDIT
		FROM BLOW_OUT
	GROUP BY LOCNBR
		    ,TRANDT
	ORDER BY LOCNBR
		    ,TRANDT
;
%RUNQUIT(&job,&sub16);

/* ADD METRICS TO OPEN LINE SUMMARIZATION */
PROC SQL;
	CREATE TABLE COMBINE AS
		SELECT OG.*
			  ,TOTAL_AVAILABLE_CREDIT
		FROM BY_LOC OG
		INNER JOIN
		SUMMARIZE SUM
		ON(OG.LOCNBR=SUM.LOCNBR
		   AND OG.BUSINESSDT=SUM.BUSINESSDT)
;
%RUNQUIT(&job,&sub16);

/* PULL COMPLIANT/DEFAULT LOANS OUTSTANDING FROM PRIMEDECK */
PROC SQL;
   CREATE TABLE WORK.RECV AS 
   SELECT T1.STATE AS STATE, 
          (UPCASE(T1.PRODUCTNAME)) AS PRODUCT, 
          (INPUT(T1.DATECREATED,YYMMDD10.)) FORMAT=MMDDYY10. AS BUSINESSDT, 
          (SUM(CASE WHEN UPCASE(T1.LOANACCOUNTINGSTATUSNAME) = 'COMPLIANT' THEN T1.LOANCOUNT ELSE 0 END)) AS COMPLIANT_LOANS_OUTSTANDING, 
          (SUM(CASE WHEN UPCASE(T1.LOANACCOUNTINGSTATUSNAME) = 'DEFAULT' THEN T1.LOANCOUNT ELSE 0 END)) AS DEFAULT_LOANS_OUTSTANDING, 
          (SUM(CASE WHEN UPCASE(T1.LOANACCOUNTINGSTATUSNAME) = 'COMPLIANT' THEN T1.PRINCIPAL ELSE 0 END)) AS TOTADVRECV, 
          (SUM(CASE WHEN UPCASE(T1.LOANACCOUNTINGSTATUSNAME) = 'DEFAULT' THEN T1.PRINCIPAL ELSE 0 END)) AS TOTDEFAULTRECV
      FROM AA_PD.LOANRECEIVABLEBYSTATE T1
      WHERE (CALCULATED PRODUCT) = 'LINEOFCREDIT'
      GROUP BY T1.STATE,
               (CALCULATED PRODUCT),
               (CALCULATED BUSINESSDT);
%RUNQUIT(&job,&sub16);

/* ADD LOCATION DIMENSIONS FROM D_LOCATION */
PROC SQL;
	CREATE TABLE LOC_DIMS AS
		SELECT 'LINEOFCREDIT' AS PRODUCT
			    ,'AANET LINEOFCREDIT' AS PRODUCT_DESC
				,'ONLINE' AS POS
				,'AANET' AS INSTANCE
			  	,'AA' AS BRANDCD
			    ,'STANDARD' AS BANKMODEL
			  	,'USA' AS COUNTRYCD
			  	,'' AS CITY
				,LOC.ST_PVC_CD AS STATE
			  	,'' AS ZIP
				,BUSINESS_UNIT
			  	,0 AS ZONENBR
			  	,'' AS ZONENAME
			  	,0 AS REGIONNBR
			  	,'' AS REGIONRDO
			  	,0 AS DIVISIONNBR
			  	,'' AS DIVISIONDDO
				,LL.LATITUDE AS LATITUDE
				,LL.LONGITUDE AS LONGITUDE
				,OL.LOCNBR
				,'LINEOFCREDIT' AS LOCATION_NAME
				,''DT AS LOC_OPEN_DT FORMAT=DATETIME20.
				,''DT AS LOC_CLOSE_DT FORMAT=DATETIME20.
				,BUSINESSDT
				,CASE WHEN NEW_ORIGINATION_LINE_COUNT = . THEN 0 ELSE NEW_ORIGINATION_LINE_COUNT END AS NEW_ORIGINATION_LINE_COUNT
				,CASE WHEN NEW_ORIGINATION_LINE_AMT = . THEN 0 ELSE NEW_ORIGINATION_LINE_AMT END AS NEW_ORIGINATION_LINE_AMT
				,TOTAL_AVAILABLE_CREDIT
		FROM WORK.COMBINE OL
		INNER JOIN 
		(SELECT DISTINCT BUSN_UNIT_ID, ST_PVC_CD FROM EDW.D_LOCATION WHERE ST_PVC_CD IS NOT MISSING) LOC
		ON(OL.BUSINESS_UNIT=LOC.BUSN_UNIT_ID)
		LEFT JOIN SKYNET.LOCATION_LATLONG LL
		ON(OL.LOCNBR=LL.LOCNBR)
	ORDER BY LOCNBR
		    ,BUSINESSDT
;
%RUNQUIT(&job,&sub16);

PROC TIMESERIES DATA=LOC_DIMS OUT=LOC_DIMS2;
BY PRODUCT PRODUCT_DESC POS INSTANCE BRANDCD BANKMODEL COUNTRYCD CITY STATE ZIP BUSINESS_UNIT ZONENBR ZONENAME 
   REGIONNBR REGIONRDO DIVISIONNBR DIVISIONDDO LOCNBR LOCATION_NAME LOC_OPEN_DT LOC_CLOSE_DT LATITUDE LONGITUDE;
ID BUSINESSDT INTERVAL=DAY;
	VAR NEW_ORIGINATION_LINE_COUNT / ACCUMULATE=NONE SETMISSING=0;
	VAR NEW_ORIGINATION_LINE_AMT / ACCUMULATE=NONE SETMISSING=0;
	VAR TOTAL_AVAILABLE_CREDIT / ACCUMULATE=NONE SETMISSING=PREVIOUS;
%RUNQUIT(&job,&sub16);

/* LAST THURSDAY CALC */

DATA DATE_BLOWOUT;
	DO I = "01JAN2000"D TO TODAY();
		BUSINESSDT = I;
		DAYNAME = COMPRESS(PUT(BUSINESSDT,DOWNAME.));
		OUTPUT;
	END;
	FORMAT BUSINESSDT MMDDYY10.;
RUN;

PROC SQL;
	CREATE TABLE HOLIDAY_NAMES AS
		SELECT DBO.*
			  ,HOL.HOLIDAYNAME
		FROM DATE_BLOWOUT DBO
		LEFT JOIN BIOR.I_HOLIDAYS HOL
		ON(DBO.BUSINESSDT=DATEPART(HOL.HOLIDAY_DT))
	ORDER BY DBO.BUSINESSDT DESC;
%RUNQUIT(&job,&sub16);

DATA THURSDAY_DATES;
	SET WORK.HOLIDAY_NAMES;
	PRIORDAYHOLIDAY = LAG1(HOLIDAYNAME);
	PRIORDATE = LAG1(BUSINESSDT);
	IF DAYNAME = 'Thursday' 
		AND BUSINESSDT ^= INTNX('MONTH',BUSINESSDT,0,'E') 
 		AND HOLIDAYNAME = '' 
			THEN THURSDAYWEEK = 'Y';
	ELSE 
		IF DAYNAME = 'Wednesday'
			AND (PRIORDAYHOLIDAY ^= '' OR PRIORDATE = INTNX('MONTH',BUSINESSDT,0,'E'))
				THEN THURSDAYWEEK = 'Y';
	ELSE 
		THURSDAYWEEK = 'N';
FORMAT PRIORDATE MMDDYY10.;
RUN;

DATA LOC_THURSDAY;
	SET WORK.LOC_DIMS2;
	LASTTHURSDAYOFMONTH = INTNX('WEEK.5',INTNX('MONTH',BUSINESSDT,0,'E'),0);
	IF LASTTHURSDAYOFMONTH = INTNX('MONTH',BUSINESSDT,0,'E')
	   OR LASTTHURSDAYOFMONTH = HOLIDAY('VETERANSUSG',YEAR(BUSINESSDT))
	   OR LASTTHURSDAYOFMONTH = HOLIDAY('VETERANS',YEAR(BUSINESSDT))
	   OR LASTTHURSDAYOFMONTH = HOLIDAY('THANKSGIVING',YEAR(BUSINESSDT))
	   OR LASTTHURSDAYOFMONTH = HOLIDAY('CHRISTMAS',YEAR(BUSINESSDT)) 
	THEN LASTTHURSDAYOFMONTH = INTNX('DAY',LASTTHURSDAYOFMONTH,-1);
	IF BUSINESSDT = LASTTHURSDAYOFMONTH THEN LASTTHURSDAY = 'Y';
	ELSE LASTTHURSDAY = 'N';
	DROP LASTTHURSDAYOFMONTH;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE ADD_THURSDAY_WEEK AS
		SELECT LOC.*
			  ,TH.THURSDAYWEEK
		FROM LOC_THURSDAY LOC
		INNER JOIN
		THURSDAY_DATES TH
		ON(LOC.BUSINESSDT=TH.BUSINESSDT)
	ORDER BY LOC.LOCNBR
		    ,LOC.BUSINESSDT
;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE HOLIDAYS AS
		SELECT DATEPART(HOLIDAY_DT) AS HOLIDAYDT FORMAT=MMDDYY10.
			  ,HOLIDAYNAME
		FROM BIOR.I_HOLIDAYS
;
%RUNQUIT(&job,&sub16);

PROC SQL;
	CREATE TABLE ADD_HOLIDAY AS
		SELECT T1.*
			  ,T2.HOLIDAYNAME
		FROM WORK.ADD_THURSDAY_WEEK T1
		LEFT JOIN
		WORK.HOLIDAYS T2
		ON(T1.BUSINESSDT = T2.HOLIDAYDT)
;
%RUNQUIT(&job,&sub16);

/* END OF LAST THURSDAY CALC */

PROC SQL;
	CREATE TABLE GROSS_REV_PRE AS
		SELECT FI_CENTER_ID AS LOCNBR
			  ,DATEPART(FD_TRANSACTION_DTTM) AS BUSINESSDT FORMAT=MMDDYY10.
			  ,SUM(FN_FINANCIAL_DETAIL_AMT*-1) AS GROSS_REVENUE
		FROM ODSFIN.MV_FINANCIAL_RECORD
		WHERE FC_TRANSACTION_CD IN('PMT','RTNCK')
			  AND FC_FINANCIAL_DETAIL_CD IN('INT','LATEFEE','NSFFEE')
			  AND FC_PRODUCT_CD = 'LOC'
		GROUP BY FI_CENTER_ID
			    ,CALCULATED BUSINESSDT
;
%RUNQUIT(&job,&sub16);

/*#################################### FIX PASTDUE COUNTS & AMOUNTS START ########################################*/
/* END DATE VARIABLE */
data _null_;
   call symputx('end_dt',put(TODAY()-1,date9.), 'g');
run;
%put &end_dt;

/* START DATE VARIABLE */
data _null_;
   start_dt1 = intnx('month',today(),-27,'beginning');
   call symputx('start_dt',put(start_dt1,date9.), 'g');
run;
%put &start_dt;



PROC SQL;
	CREATE TABLE Table_0a AS
		SELECT 
		DISTINCT
         t2.loanid,
          T1.FI_CENTER_ID
	FROM AA_LOC.LOAN T2
	INNER JOIN 
	AA_LOC.FINANCIALACCTTRN T1
	ON(T2.LOANID=T1.FC_LOANID)
	WHERE T2.LOANTYPEID = 3
;
%RUNQUIT(&job,&sub16);

proc sql;
	create table table_1a as
		select *
		from aa_loc.LoanStatusLog
		where loanid in (select distinct loanid
						 from table_0A
						)
		order by loanid
				,startdate
	;
%RUNQUIT(&job,&sub16);

proc sql;
	create table Table_1 as
		select t1.*
			  ,datepart(t1.startdate) as start2 format=date9.
			  ,INPUT(EFFECTIVEDATE,yymmdd10.) as start_2a format=date9.
			  ,t2.*
		from table_1a t1
			left join Table_0a t2
				on t1.loanid = t2.loanid
		;
quit;

/*data table_1;*/
/*	set aa_loc.LoanStatusLog;*/
/*	format Start2 date9.;*/
/*	where LoanID = 3232039;*/
/*	start2 = datepart(startdate);*/
/*run;*/

proc sort data=table_1;
/*	by loanID start2 startdate;*/
	by loanID start_2a startdate;
run;

data table_2;
	set table_1;
/*	by loanID start2 startdate;*/
	by loanID start_2a startdate;
	if last.start_2a;
run;

/* CREATE DAILY RECORD FOR PAST 2 YEARS
   FOR EACH LOAN WITH THE TOTAL_OWED AT
   THAT TIME, IF NO CHANGE, KEEP PREVIOUS
   TOTAL_OWED AMOUNT RETAINED UNTIL CHANGE */
proc timeseries data=table_2 out=mseries;
   by LoanID;
/*   id start2 interval=day*/
   id start_2a interval=day
                accumulate=NONE
                setmiss=prev
/*                start='01FEB2016'd*/
/*                end  ='01MAY2018'd;*/
                start="&start_dt"d
                end="&end_dt"d;
   var loanstatusid;
run;

data pastdue_flagged;
	set mseries;
	if LoanStatusID in (13,29)
		then pastdue_flg = 1;
run;

/*---------------------------------------------*/
proc sql;
	create table LoanStatusInfo as
		select	a.LoanID,	
				a.LoanStatusID,
				a.StartDate,
				a.EffectiveDate,
				b.LoanStatusName
		from AA_LOC.LoanStatusLog as a
			left join AA_LOC.LoanStatus as b
				on a.LoanStatusID = b.LoanStatusID
		where LoanID in (select distinct FC_LoanID from INITIAL_PULL)
		order by a.LoanID,
				 a.StartDate
	;
%RUNQUIT(&job,&sub16);

data PastDueDateRange;		
	set LoanStatusInfo(rename = (LoanStatusName = To_Status));
	by	LoanID
		StartDate
	;
	From_Status = lag(To_Status);

	if first.LOANID then From_Status = ''; 

	if not first.LoanID;

	format start_dt date9.;
/*	start_dt = datepart(startdate);*/
	start_dt = INPUT(EFFECTIVEDATE,yymmdd10.);

	
run;

data PastDueDateRange2;		
	set PastDueDateRange;
	if From_Status = "Right To Cure"
		then From_Status = "Past Due";
	if To_status = "Right To Cure"
		then To_status = "Past Due";
run;
	
data PastDueDateRange3;		
	set PastDueDateRange2;
	if From_Status = "Past Due" and To_status = "Past Due"
		then keep_flg = 0;
	else keep_flg = 1;
	if keep_flg = 1;
run;

/*---------------------------------------------*/


proc sql;
	create table pastdue_range as
		select t1.*
			  ,t2.*
		from work.pastdue_flagged t1
			left join work.pastduedaterange3 t2
				on t1.LoanID = t2.loanid
/*				and t1.start2 = t2.start_dt*/
				and t1.start_2a = t2.start_dt
	;
quit;

data pastduedate;
	set pastdue_range;
	if pastdue_flg = 1;
	drop EffectiveDate;
run;

proc sql;
	create table pastduedate1 as
		select t1.*
			  ,t2.*
		from pastduedate t1
			left join Table_0a t2
				on t1.loanid = t2.loanid
		order by t1.loanid
/*				,t1.start2*/
				,t1.start_2a
	;
quit;

data pastduedate2;
	set pastduedate1;
	retain _start;
	if not missing(start_dt)
		then _start = start_dt;
	else start_dt = _start;
	drop _start;
run;

data pastduedate3;
	set pastduedate2;
/*	pastduedays = start2 - start_dt + 1;*/
	pastduedays = start_2a - start_dt + 1;
	drop keep_flg;
run;

data pastduedate4;
	set pastduedate3;
	if pastduedays >= 1 and pastduedays <= 9
		then PASTDUECNT_1 = 1;
	else if pastduedays >= 10
		then PASTDUECNT_2 = 1;
run;

data pastduedate5;
	set pastduedate4;
	if PASTDUECNT_1 = .
		then PASTDUECNT_1 = 0;
	if PASTDUECNT_2 = .
		then PASTDUECNT_2 = 0;
run;

/*################### PAST DUE BUCKETS END ###################*/




/*################## PAST DUE AMOUNTS START ##################*/

proc sql;
	create table pdamt as
		select *
		from aa_loc.FinancialAcctTrn
		where fc_loanid in (select distinct loanid
							from pastduedate5
						   )
	;
quit;

proc sort data=pdamt;
	by FC_LoanID
	   FD_TransAction_Dttm
	   FinancialAcctTrnID
	;
run;

data pdamt_2;
	set pdamt;
	by FC_LoanID FD_TransAction_Dttm;
	if last.fd_transaction_dttm;
/*	where FC_LoanID = 3232039;*/
	trandt = datepart(fd_transaction_dttm);
run;

proc timeseries data=pdamt_2 out=pdamt_3;
   by FC_LoanID;
   id trandt interval=day
                accumulate=NONE
                setmiss=prev
/*                start='01FEB2016'd*/
/*                end  ='01MAY2018'd;*/
                start="&start_dt"d
                end="&end_dt"d;
   var FN_Loan_Total_Owed;
run;

/*################### PAST DUE AMOUNTS END ###################*/

/*pastduedate5;*/

proc sql;
	create table almost_done as
		select t1.*
			  ,t2.*
		from pastduedate5 t1
			left join pdamt_3 t2
				on t1.loanid = t2.fc_loanid
/*					and t1.start2 = t2.trandt*/
					and t1.start_2a = t2.trandt
/*		where t1.loanid = 3232039*/
		order by t1.loanid
/*				,t1.start2*/
				,t1.start_2a
	;
quit;

data pstdue_amt;
	set almost_done;
	if PASTDUECNT_1 = 1
		then PASTDUEAMT_1 = FN_Loan_Total_Owed;
	if PASTDUECNT_2 = 1
		then PASTDUEAMT_2 = FN_Loan_Total_Owed;
run;


proc tabulate
	data=pstdue_amt
	out=pastdue_rollup;


	var pastdueamt_1
		pastdueamt_2
		pastduecnt_1
		pastduecnt_2
	;

/*	class start2;*/
	class start_2a;

	class FI_Center_ID;

	table FI_Center_ID
/*			*start2*/
			*start_2a
	,
		PASTDUECNT_1 = '' * SUM = "PASTDUECNT_1" * F = COMMA12. * [STYLE=[FONTSIZE=10PT JUST =C]]
		PASTDUEAMT_1 = '' * SUM = "PASTDUEAMT_1" * F = 10.2 * [STYLE=[FONTSIZE=10PT JUST =C]]
		PASTDUECNT_2 = '' * SUM = "PASTDUECNT_2" * F = COMMA12. * [STYLE=[FONTSIZE=10PT JUST =C]]
		PASTDUEAMT_2 = '' * SUM = "PASTDUEAMT_2" * F = 10.2 * [STYLE=[FONTSIZE=10PT JUST =C]]
	;
quit;


data pastdue_rollup2;
	set pastdue_rollup;
	drop _page_
		 _table_
		 _type_
	;
	rename	pastdueamt_1_sum = pastdueamt_1
			pastdueamt_2_sum = pastdueamt_2
			pastduecnt_1_sum = pastduecnt_1
			pastduecnt_2_sum = pastduecnt_2
	;
	if pastdueamt_1_sum = .
		then pastdueamt_1_sum = 0;
	if pastdueamt_2_sum = .
		then pastdueamt_2_sum = 0;

run;
/*##################################### FIX PASTDUE COUNTS & AMOUNTS END #########################################*/




/* ################################################*/
/*                   FIX WORAMTSUM                 */
/* ################################################*/

/* get distinct loanid with center info for later */
proc sql;
	create table loanid_locnbr as
		select distinct fc_loanid, FI_Center_ID
		from work.initial_pull
	;
quit;

/* 1st step to get WO date for loans */
proc sql;
	create table loc_only_LASLog as
		select t1.*
		from aa_loc.LoanAccountingStatusLog t1
			inner join loanid_locnbr t2
				on t1.LoanID = t2.fc_loanid
		order by loanid
				,EffectiveDate
	;
quit;

proc sql;
	create table loc_only_LASLog_2 as
		select *
		from loc_only_LASLog
		where ToLoanAccountingStatusID = 2
	;
quit;

proc sql;
	create table loc_only_LASLog_3 as
		select loanid
			  ,input(EffectiveDate,YYMMDD10.) AS WriteOffDt FORMAT date9.
		from loc_only_LASLog_2
		order by loanid
				,WriteOffDt

	;
quit;

/* get transaction data for the loanids with writeoff status */
proc sql;
	create table test_loc_woff as
		select t1.*
		from aa_loc.vw_trn t1
		where t1.loanid in (select distinct loanid
							from work.loc_only_LASLog_3)
	;
quit;

proc sql;
	create table test_loc_woff2 as
		select t1.*
			  ,t2.*
		from test_loc_woff t1
			left join loc_only_LASLog_3 t2
				on t1.loanid = t2.loanid
	;
quit;

/* remove unwanted transactions & check keep transactions after writeoff date*/
proc sql;
	create table test_loc_woff3 as
   SELECT
          t1.TrnID, 
          t1.LoanID, 
          t1.TrnTypeID, 
          t1.TrnTypeName, 
          t1.TrnSubTypeID, 
          t1.TrnSubTypeName, 
          t1.TrnDirectionID, 
          t1.TrnDirectionName, 
          t1.Renewal, 
		  input(t1.EffectiveDate,YYMMDD10.) format=date9. AS TranDT,
		  t1.WriteOffDt,
		  t1.PostDate, 
          t1.Principal, 
          t1.Interest, 
          t1.Fee, 
          t1.Total, 
          t1.IsPending, 
          t1.CreatedByUserProfileID, 
          t1.IsPymt, 
          t1.IsPymtReturn, 
          t1.IsFunding, 
          t1.TrnStatusName, 
          t1.TrnMetaDataID, 
          t1.CheckNbr, 
          t1.ABANbr, 
          t1.AcctNbr, 
          t1.MTCN, 
          t1.SerialNbr, 
          t1.TrnPymtID, 
          t1.TrnReturnID, 
          t1.DocID, 
          t1.FileTypeID, 
          t1.DocFileName, 
          t1.IsBatchACH, 
          t1.IsOriginationFee, 
          t1.AccountingDate, 
          t1.TrnGUID, 
          t1.LOCTrnTypeCode, 
          t1.ACHProviderID, 
          t1.IsRefund, 
          t1.DateCreated, 
          t1.VoidedTrnID, 
          t1.IsCashFlow
      FROM WORK.TEST_LOC_WOFF2 t1
	  where calculated trandt >= writeoffdt
		and t1.TrnTypeName not in ( 'Adjustment'
							   ,'Reverse Interest'
							   )
	  order by t1.loanid
	  		  ,calculated trandt
	;
%RUNQUIT(&job,&sub16);

proc sql;
	create table wor_roll_up as
		select LoanID
			  ,trandt
			  ,sum(total) as WORAMTSUM
		from test_loc_woff3
		group by loanID
			    ,trandt
		order by loanid
				,trandt
	;
quit;

/* add location detail */
proc sql;
	create table Location_details as
		select t1.*
			  ,input(compress(t2.FI_Center_ID),8.) as locnbr
			  ,t2.FC_LoanID
		from wor_roll_up t1
			left join loanid_locnbr t2
				on t1.loanid = t2.FC_LoanID
	;
quit;

/* Roll up woramtsum by center and date */
proc sql;
	create table wor_roll_up2 as
		select locnbr
			  ,trandt
			  ,(sum(WORAMTSUM))*-1 as WORAMTSUM
		from Location_details
		group by locnbr
			    ,trandt
		order by locnbr
				,trandt
	;
quit;
/* ################################################*/
/*                  END FIX WORAMTSUM              */
/* ################################################*/








/* ADD ALL METRICS PULL IN PRIOR STEPS */
PROC SQL;
	CREATE TABLE WORK.LOC_DAILYSUMMARY_PRE AS
		SELECT T1.*
		      ,CASE WHEN ACTIVE_CNT = . THEN 0 ELSE ACTIVE_CNT END AS ACTIVE_CREDIT_LINE_CNT
			  ,CASE WHEN ACTIVE_AMT = . THEN 0 ELSE ACTIVE_AMT END AS ACTIVE_CREDIT_LINE_AMT
			  ,CASE WHEN T3.DEFAULT_CNT = . THEN 0 ELSE T3.DEFAULT_CNT END AS DEFAULT_CREDIT_LINE_CNT
			  ,CASE WHEN T3.DEFAULT_AMT = . THEN 0 ELSE T3.DEFAULT_AMT END AS DEFAULT_CREDIT_LINE_AMT
		      ,CASE WHEN T4.DEFAULT_CNT = . THEN 0 ELSE T4.DEFAULT_CNT END AS DEFAULT_CNT
			  ,CASE WHEN T4.DEFAULT_AMT = . THEN 0 ELSE T4.DEFAULT_AMT END AS DEFAULT_AMT
			  ,CASE WHEN T5.WO_AMT = . THEN 0 ELSE T5.WO_AMT END AS WOAMTSUM

/*			  Added 9.18.18 */
			  ,CASE WHEN t11.WORAMTSUM = . then 0 ELSE t11.WORAMTSUM END AS WORAMTSUM

			  ,CASE WHEN T5.WO_CNT = . THEN 0 ELSE T5.WO_CNT END AS WOCNT
			  ,CASE WHEN T6.FIRSTDRAWAMT = . THEN 0 ELSE T6.FIRSTDRAWAMT END AS FIRSTDRAWAMT
			  ,CASE WHEN T6.FIRSTDRAWCNT = . THEN 0 ELSE T6.FIRSTDRAWCNT END AS FIRSTDRAWCNT
			  ,CASE WHEN T7.OVERALLDRAWAMT = . THEN 0 ELSE T7.OVERALLDRAWAMT END AS OVERALLDRAWAMT
			  ,CASE WHEN T7.OVERALLDRAWCNT = . THEN 0 ELSE T7.OVERALLDRAWCNT END AS OVERALLDRAWCNT
/*			  ,CASE WHEN T9.PASTDUECNT_1 = . THEN 0 ELSE T9.PASTDUECNT_1 END AS PASTDUECNT_1*/
/*			  ,CASE WHEN T9.PASTDUEAMT_1 = . THEN 0 ELSE T9.PASTDUEAMT_1 END AS PASTDUEAMT_1*/
/*			  ,CASE WHEN T9.PASTDUECNT_2 = . THEN 0 ELSE T9.PASTDUECNT_2 END AS PASTDUECNT_2*/
/*			  ,CASE WHEN T9.PASTDUEAMT_2 = . THEN 0 ELSE T9.PASTDUEAMT_2 END AS PASTDUEAMT_2*/
			  ,CASE WHEN T10.PASTDUECNT_1 = . THEN 0 ELSE T10.PASTDUECNT_1 END AS PASTDUECNT_1
			  ,CASE WHEN T10.PASTDUEAMT_1 = . THEN 0 ELSE T10.PASTDUEAMT_1 END AS PASTDUEAMT_1
			  ,CASE WHEN T10.PASTDUECNT_2 = . THEN 0 ELSE T10.PASTDUECNT_2 END AS PASTDUECNT_2
			  ,CASE WHEN T10.PASTDUEAMT_2 = . THEN 0 ELSE T10.PASTDUEAMT_2 END AS PASTDUEAMT_2

			  /*      Added 9.18.18      */
/*			  ,CASE WHEN COMPLIANT_LOANS_OUTSTANDING = . THEN 0 ELSE COMPLIANT_LOANS_OUTSTANDING END AS TOTALLINERECVCNT*/
/*	TEST      ,CASE WHEN COMPLIANT_LOANS_OUTSTANDING = . THEN 0 ELSE COMPLIANT_LOANS_OUTSTANDING END AS TOTALCOMPLIANTRECVCNT*/
			  ,CASE WHEN (SUM(DEFAULT_LOANS_OUTSTANDING,COMPLIANT_LOANS_OUTSTANDING)) = . THEN 0
					ELSE (SUM(DEFAULT_LOANS_OUTSTANDING,COMPLIANT_LOANS_OUTSTANDING)) END AS TOTALLINERECVCNT

			  ,CASE WHEN COMPLIANT_LOANS_OUTSTANDING = . THEN 0 ELSE COMPLIANT_LOANS_OUTSTANDING END AS TOTALLINERECVCNT
			  ,CASE WHEN TOTADVRECV = . THEN 0 ELSE TOTADVRECV END AS TOTALLINERECV
			  ,CASE WHEN DEFAULT_LOANS_OUTSTANDING = . THEN 0 ELSE DEFAULT_LOANS_OUTSTANDING END AS TOTALDEFAULTLINERECVCNT
			  ,CASE WHEN TOTDEFAULTRECV = . THEN 0 ELSE TOTDEFAULTRECV END AS TOTALDEFAULTLINERECV
			  ,COALESCE(T8.GROSS_REVENUE,0) AS GROSS_REVENUE
			  ,CASE WHEN WEEKDAY(TODAY()) = 2 THEN TODAY()-2 ELSE TODAY()-1 END AS LAST_REPORT_DT FORMAT=MMDDYY10.
		FROM WORK.ADD_HOLIDAY T1
		LEFT JOIN
		WORK.RECV T2
		ON(T1.STATE=T2.STATE AND	
		   T1.BUSINESSDT=T2.BUSINESSDT)
		LEFT JOIN WORK.SUMMARIZE_ACTIVE T3
		ON(T1.LOCNBR=T3.LOCNBR AND
		   T1.BUSINESSDT=T3.BUSINESSDT)
		LEFT JOIN WORK.DEFAULT_CNT_AMT T4
		ON(T1.LOCNBR=T4.LOCNBR AND
		   T1.BUSINESSDT=T4.BUSINESSDT)
		LEFT JOIN WORK.WO_CNT_AMT T5
		ON(T1.LOCNBR=T5.LOCNBR AND
		   T1.BUSINESSDT=T5.BUSINESSDT)
		LEFT JOIN WORK.FIRST_DRAW T6
		ON(T1.LOCNBR=T6.LOCNBR AND
		   T1.BUSINESSDT=T6.BUSINESSDT)
		LEFT JOIN WORK.OVERALL_DRAW T7
		ON(T1.LOCNBR=T7.LOCNBR AND
		   T1.BUSINESSDT=T7.BUSINESSDT)
		LEFT JOIN WORK.GROSS_REV_PRE T8
		ON(T1.LOCNBR=T8.LOCNBR AND	
		   T1.BUSINESSDT=T8.BUSINESSDT)
/*		LEFT JOIN WORK.PAST_DUE T9*/
/*		ON(T1.LOCNBR=T9.LOCNBR AND*/
/*		   T1.BUSINESSDT=T9.BUSINESSDT)*/
		LEFT JOIN WORK.PASTDUE_ROLLUP2 t10
		ON(COMPRESS(PUT(T1.LOCNBR,10.))=COMPRESS(T10.FI_CENTER_ID) AND
/*		   T1.BUSINESSDT=T10.START2)*/
		   T1.BUSINESSDT=T10.START_2A)
		LEFT JOIN WORK.wor_roll_up2 T11
		ON (T1.LOCNBR = T11.locnbr AND
			t1.businessdt = t11.trandt)

;
QUIT;


%MACRO WAITFORCUSTLIFE();


	%DO %UNTIL (%EVAL(&COUNT_R. >= 1));	
		PROC SQL;
			CREATE TABLE CUST_LIFE_CHECK_TODAY AS
			SELECT INSTANCE
				  ,PRODUCT	
				  ,MAX(BUSINESS_DATE)	AS BUSINESSDT
			FROM BIOR.CUST_CATEGORY_DAILY_COUNT
			WHERE PRODUCT='LINEOFCREDIT' AND INSTANCE = 'AANET'
			GROUP BY INSTANCE
		;
		QUIT;

		DATA _NULL_;
			FORMAT WEEKDAY $20.;
			DAYOFWEEK = WEEKDAY(DATE());
			IF DAYOFWEEK = 1 THEN WEEKDAY = 'SUNDAY';
			ELSE IF DAYOFWEEK = 2 THEN WEEKDAY = 'MONDAY';
			ELSE IF DAYOFWEEK = 3 THEN WEEKDAY = 'TUESDAY';
			ELSE IF DAYOFWEEK = 4 THEN WEEKDAY = 'WEDNESDAY';
			ELSE IF DAYOFWEEK = 5 THEN WEEKDAY = 'THURSDAY';
			ELSE IF DAYOFWEEK = 6 THEN WEEKDAY = 'FRIDAY';
			ELSE IF DAYOFWEEK = 7 THEN WEEKDAY = 'SATURDAY';
			CALL SYMPUTX("DAYOFWEEK",WEEKDAY,'G');
		RUN;

		%IF &DAYOFWEEK. = SUNDAY
			OR &DAYOFWEEK. = TUESDAY
			OR &DAYOFWEEK. = WEDNESDAY
			OR &DAYOFWEEK. = THURSDAY
			OR &DAYOFWEEK. = FRIDAY
			OR &DAYOFWEEK. = SATURDAY %THEN 
				%DO;

					/*LOC*/
					PROC SQL;
						SELECT COUNT(*) INTO: COUNT_R
						FROM CUST_LIFE_CHECK_TODAY
						WHERE PRODUCT='LINEOFCREDIT' AND INSTANCE = 'AANET' AND BUSINESSDT >= DHMS(TODAY()-1,00,00,00)
					;
					QUIT;

				%END;
		%ELSE %IF &DAYOFWEEK. = MONDAY %THEN
				%DO;

					/*LOC*/
					PROC SQL;
						SELECT COUNT(*) INTO: COUNT_R
						FROM CUST_LIFE_CHECK_TODAY
						WHERE PRODUCT='LINEOFCREDIT' AND INSTANCE = 'AANET' AND BUSINESSDT >= DHMS(TODAY()-2,00,00,00)
					;
					QUIT;
				%END;
					
		%PUT THE COUNT IS EQUAL TO : &COUNT_R;

		%IF %EVAL(&COUNT_R. < 1) %THEN 
			%DO;
				/*SLEEPS FOR 300 SECONDS (5 MINUTES) UNTIL IT FINDS 16 FINISHED TABLES, IT WILL LOOP FOREVER UNTIL THE 16 FINISHED TABLES*/
				DATA SLEEP;
					CALL SLEEP(300,1);
				RUN;
			%END;
	%END;

%MEND;

%WAITFORCUSTLIFE

/* NEWCUSTCNTCOMPANY */
PROC SQL;
CREATE TABLE WORK.NEWCUSTCNT_LOC AS
	SELECT
		INSTANCE
	   ,PRODUCT
	   ,PRODUCTDESC
	   ,CASE WHEN LOCATION_NBR = 17 THEN 6864 ELSE . END AS LOCNBR
	   ,DATEPART(BUSINESS_DATE) AS BUSINESSDT FORMAT=MMDDYY10.
	   ,SUM(SUM(NEW_CUST_CNT,NEW_REPEAT_CUST_CNT)) AS NEWCUSTCNTCOMPANY
	FROM BIOR.CUST_CATEGORY_DAILY_COUNT
	WHERE PRODUCT = 'LINEOFCREDIT'
	GROUP BY 
		INSTANCE
	   ,PRODUCT
	   ,PRODUCTDESC
	   ,CALCULATED LOCNBR
	   ,CALCULATED BUSINESSDT
	ORDER BY 
		INSTANCE
	   ,PRODUCT
	   ,PRODUCTDESC
	   ,CALCULATED LOCNBR
	   ,CALCULATED BUSINESSDT
;
%RUNQUIT(&job,&sub16);

PROC SQL;
   CREATE TABLE LOC_SRC.LOC_DAILYSUMMARY AS 
   SELECT t1.PRODUCT, 
          t1.PRODUCT_DESC, 
          t1.POS, 
          t1.INSTANCE, 
          t1.BRANDCD, 
          t1.BANKMODEL, 
          t1.COUNTRYCD, 
          t1.CITY, 
          t1.STATE, 
          t1.ZIP, 
          t1.BUSINESS_UNIT, 
          t1.ZONENBR, 
          t1.ZONENAME, 
          t1.REGIONNBR, 
          t1.REGIONRDO, 
          t1.DIVISIONNBR, 
          t1.DIVISIONDDO, 
          t1.LOCNBR, 
          t1.LOCATION_NAME, 
          DHMS(t1.BUSINESSDT,00,00,00) AS BUSINESSDT FORMAT=DATETIME20., 
          DHMS(t1.LAST_REPORT_DT,00,00,00) AS LAST_REPORT_DT FORMAT=DATETIME20., 
          t1.LOC_OPEN_DT, 
          t1.LOC_CLOSE_DT, 
          t1.LATITUDE, 
          t1.LONGITUDE, 
          t1.HOLIDAYNAME, 
          t1.LASTTHURSDAY, 
          t1.THURSDAYWEEK, 
          t1.NEW_ORIGINATION_LINE_COUNT, 
          t1.NEW_ORIGINATION_LINE_AMT, 
          t1.TOTAL_AVAILABLE_CREDIT, 
          t1.ACTIVE_CREDIT_LINE_CNT, 
          t1.ACTIVE_CREDIT_LINE_AMT, 
          t1.DEFAULT_CREDIT_LINE_CNT, 
          t1.DEFAULT_CREDIT_LINE_AMT, 
          t1.DEFAULT_CNT, 
          t1.DEFAULT_AMT, 
          t1.WOAMTSUM, 
          t1.WOCNT, 
		  CASE WHEN NCC.NEWCUSTCNTCOMPANY = . THEN 0 ELSE NCC.NEWCUSTCNTCOMPANY END AS NEWCUSTCNTCOMPANY,
          t1.FIRSTDRAWAMT, 
          t1.FIRSTDRAWCNT, 
          t1.OVERALLDRAWAMT, 
          t1.OVERALLDRAWCNT, 
          t1.PASTDUECNT_1, 
		  t1.PASTDUEAMT_1,
          t1.PASTDUECNT_2, 
		  T1.PASTDUEAMT_2,
          t1.TOTALLINERECVCNT, 
          t1.TOTALLINERECV, 
          t1.TOTALDEFAULTLINERECVCNT, 
          t1.TOTALDEFAULTLINERECV, 
          t1.GROSS_REVENUE,
		  t1.WOAMTSUM AS GROSS_WRITE_OFF,
		  t1.WOAMTSUM AS NET_WRITE_OFF,

/*        Added 9.18.18  */
/*		  . AS WORAMTSUM,*/
		  t1.WORAMTSUM,

		  SUM(t1.GROSS_REVENUE,-t1.WOAMTSUM) AS NET_REVENUE
      FROM LOC_DAILYSUMMARY_PRE t1
	  LEFT JOIN
	  WORK.NEWCUSTCNT_LOC NCC
	  ON(T1.LOCNBR=NCC.LOCNBR AND
	  	 T1.BUSINESSDT=NCC.BUSINESSDT AND
		 T1.INSTANCE=NCC.INSTANCE)
;
%RUNQUIT(&job,&sub16);

%INCLUDE "\\CSSSASAPP\CADA\SAS SOURCE CODE\PRODUCTION\SERVICE ACCOUNTS\SVC_SASUSER.SAS";
LIBNAME LOC_SRC "E:\SHARED\CADA\SAS DATA\DATAMART\LoC DAILY SUMMARY\";

LIBNAME BIOR ORACLE
	USER=&USER
	PW=&PASSWORD
	PATH=BIOR
	SCHEMA=BIOR;

PROC SQL;
	CONNECT TO ORACLE(USER=&USER PASSWORD=&PASSWORD PATH='BIOR');
	EXEC(TRUNCATE TABLE BIOR.O_DAILY_SUMMARY_LOC) BY ORACLE;
	DISCONNECT FROM ORACLE;
QUIT;

/* CREATE TIMESTAMP */
PROC FORMAT;
	PICTURE WHATDAYISIT OTHER=%0Y.%0M.%0D (DATATYPE=DATE);
	PICTURE WHATTIMEISIT OTHER=%0H.%0M.%0S (DATATYPE=TIME);
%RUNQUIT(&job,&sub15);

DATA _NULL_;
	CALL SYMPUTX('TIMESTAMP',TRANWRD(PUT(DATETIME(),DATETIME20.),':','.'),'G');
RUN;

%PUT &TIMESTAMP;

/*KICK OFF FUSE_TRANSPOSE UPLOAD*/
SYSTASK COMMAND "'C:\PROGRAM FILES\SASHOME\SASFOUNDATION\9.4\SAS.EXE'
				 '&DAILY_FILE_PATH.\TRANSPOSE LOC.SAS'
				 -LOG '&DAILY_LOGPATH.\LOC_TRANSPOSE_&TIMESTAMP..LOG'
				 -CONFIG 'C:\PROGRAM FILES\SASHOME\SASFOUNDATION\9.4\SASV9.CFG'"
TASKNAME=LOC_TRANSPOSE
STATUS=LOC_TRANSPOSE;

PROC SQL;
	INSERT INTO BIOR.O_DAILY_SUMMARY_LOC
	SELECT * FROM LOC_SRC.LOC_DAILYSUMMARY
;
QUIT;

WAITFOR _ALL_ LOC_TRANSPOSE;


/*ABORT PROGRAM*/
%MACRO STOPPROGRAM();

	%IF %EVAL(1=1) %THEN %DO;
		%ABORT CANCEL;
	%END;

%MEND;

%STOPPROGRAM




